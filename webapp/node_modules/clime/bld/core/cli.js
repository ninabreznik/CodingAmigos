"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FS = require('fs');
var Path = require('path');
var thenfail_1 = require('thenfail');
var command_1 = require('./command');
var object_1 = require('./object');
var error_1 = require('./error');
var hasOwnProperty = Object.prototype.hasOwnProperty;
var COMMAND_NAME_REGEX = /^[\w\d]+(?:-[\w\d]+)*$/;
var HELP_OPTION_REGEX = /^(?:-[h?]|--help)$/;
/**
 * Clime command line interface.
 */
var CLI = (function () {
    function CLI(
        /** Command entry name. */
        name, 
        /** Root directory of command modules. */
        root) {
        this.name = name;
        this.root = Path.resolve(root);
    }
    CLI.prototype.execute = function (argv, cwd) {
        var _this = this;
        if (cwd === void 0) { cwd = process.cwd(); }
        return thenfail_1.default.then(function () {
            var _a = _this.preProcessArguments(argv), commands = _a.commands, args = _a.args, path = _a.path;
            var isFile = FS.statSync(path).isFile();
            var description;
            if (isFile) {
                var module_1 = require(path);
                var TargetCommand = module_1.default || module_1;
                if (TargetCommand.prototype instanceof command_1.Command) {
                    if (!TargetCommand.decorated) {
                        throw new TypeError("Command defined in module \"" + path + "\" does not seem to be intialized, make sure to decorate it with `@command()`");
                    }
                    TargetCommand.path = path;
                    TargetCommand.sequence = commands;
                    var argsParser = new ArgsParser(TargetCommand);
                    var _b = argsParser.parse(commands, args, cwd), commandArgs = _b.args, commandExtraArgs = _b.extraArgs, commandOptions = _b.options, context_1 = _b.context, help = _b.help;
                    var command = new TargetCommand();
                    if (help) {
                        return command_1.HelpInfo.build(TargetCommand);
                    }
                    return _this.executeCommand(command, commandArgs, commandExtraArgs, commandOptions, context_1);
                }
                else if (Path.basename(path) === 'default.js') {
                    path = Path.dirname(path);
                    description = TargetCommand.description;
                }
                else {
                    throw new TypeError("Module \"" + path + "\" is expected to be a command");
                }
            }
            var helpInfo = command_1.HelpInfo.build(path, description);
            if (args.some(function (arg) { return HELP_OPTION_REGEX.test(arg); })) {
                return helpInfo;
            }
            else {
                throw helpInfo;
            }
        });
    };
    CLI.prototype.preProcessArguments = function (argv) {
        var commands = [this.name];
        var searchPath = this.root;
        var argsIndex = 0;
        var entryPath = Path.join(this.root, 'default.js');
        var targetPath = FS.existsSync(entryPath) ? entryPath : searchPath;
        outer: for (var i = argsIndex; i < argv.length; i++) {
            var arg = argv[i];
            if (COMMAND_NAME_REGEX.test(arg)) {
                searchPath = Path.join(searchPath, arg);
                var possiblePaths = [
                    searchPath + '.js',
                    Path.join(searchPath, 'default.js'),
                    searchPath
                ];
                for (var _i = 0, possiblePaths_1 = possiblePaths; _i < possiblePaths_1.length; _i++) {
                    var possiblePath = possiblePaths_1[_i];
                    if (FS.existsSync(possiblePath)) {
                        targetPath = possiblePath;
                        argsIndex = i + 1;
                        commands.push(arg);
                        continue outer;
                    }
                }
                // If a directory at path `searchPath` does not exist, stop searching.
                if (!FS.existsSync(searchPath)) {
                    break;
                }
            }
            else {
                break;
            }
        }
        return {
            commands: commands,
            args: argv.slice(argsIndex),
            path: targetPath
        };
    };
    CLI.prototype.executeCommand = function (command, commandArgs, commandExtraArgs, commandOptions, context) {
        var executeMethodArgs = commandArgs.concat();
        if (commandExtraArgs) {
            executeMethodArgs.push(commandExtraArgs);
        }
        if (commandOptions) {
            executeMethodArgs.push(commandOptions);
        }
        if (context) {
            executeMethodArgs.push(context);
        }
        return command.execute.apply(command, executeMethodArgs);
    };
    CLI.prototype.getHelp = function () {
        return command_1.HelpInfo.build(this.root);
    };
    return CLI;
}());
exports.CLI = CLI;
var ArgsParser = (function () {
    function ArgsParser(command) {
        this.helpProvider = command;
        this.paramDefinitions = command.paramDefinitions;
        this.requiredParamsNumber = command.requiredParamsNumber;
        this.paramsDefinition = command.paramsDefinition;
        this.optionsConstructor = command.optionsConstructor;
        this.optionDefinitions = command.optionDefinitions;
        this.contextConstructor = command.contextConstructor;
        if (this.optionDefinitions) {
            this.optionFlagMapping = {};
            this.optionDefinitionMap = {};
            for (var _i = 0, _a = this.optionDefinitions; _i < _a.length; _i++) {
                var definition = _a[_i];
                var name_1 = definition.name, flag = definition.flag;
                this.optionDefinitionMap[name_1] = definition;
                if (flag) {
                    this.optionFlagMapping[flag] = name_1;
                }
            }
        }
    }
    ArgsParser.prototype.parse = function (sequence, args, cwd) {
        var that = this;
        var ContextConstructor = this.contextConstructor || command_1.Context;
        var context = new ContextConstructor({
            cwd: cwd,
            commands: sequence
        });
        args = args.concat();
        var OptionConstructor = this.optionsConstructor;
        var optionDefinitions = this.optionDefinitions;
        var optionDefinitionMap = this.optionDefinitionMap || {};
        var optionFlagMapping = this.optionFlagMapping || {};
        var requiredOptionMap;
        var paramDefinitions = this.paramDefinitions || [];
        var pendingParamDefinitions = paramDefinitions.concat();
        var paramsDefinition = this.paramsDefinition;
        var argsNumber = args.length;
        var commandArgs = [];
        var commandExtraArgs = paramsDefinition && [];
        var commandOptions;
        if (OptionConstructor) {
            commandOptions = new OptionConstructor();
            requiredOptionMap = {};
            for (var _i = 0, optionDefinitions_1 = optionDefinitions; _i < optionDefinitions_1.length; _i++) {
                var definition = optionDefinitions_1[_i];
                var name_2 = definition.name, key = definition.key, type = definition.type, required = definition.required, validators = definition.validators, toggle = definition.toggle, defaultValue = definition.default;
                if (required) {
                    requiredOptionMap[name_2] = true;
                }
                if (toggle) {
                    commandOptions[key] = false;
                }
                else {
                    commandOptions[key] = typeof defaultValue === 'string' ?
                        castArgument(defaultValue, name_2, type, validators) :
                        defaultValue;
                }
            }
        }
        while (args.length) {
            var arg = args.shift();
            if (arg === '-?' ||
                (arg === '-h' && !hasOwnProperty.call(optionFlagMapping, 'h')) ||
                (arg === '--help' && !hasOwnProperty.call(optionDefinitionMap, 'help'))) {
                return {
                    help: true
                };
            }
            if (arg[0] === '-') {
                if (arg[1] === '-') {
                    consumeToggleOrOption(arg.substr(2));
                }
                else {
                    consumeFlags(arg.substr(1));
                }
            }
            else if (pendingParamDefinitions.length) {
                var definition = pendingParamDefinitions.shift();
                var casted = castArgument(arg, definition.name, definition.type, definition.validators);
                commandArgs.push(casted);
            }
            else if (paramsDefinition) {
                var casted = castArgument(arg, paramsDefinition.name, paramsDefinition.type, paramsDefinition.validators);
                commandExtraArgs.push(casted);
            }
            else {
                throw new UsageError("Expecting " + paramDefinitions.length + " parameter(s) at most but got " + argsNumber + " instead", this.helpProvider);
            }
        }
        {
            var expecting = this.requiredParamsNumber;
            var got = commandArgs.length;
            if (got < expecting) {
                var missingArgNames = pendingParamDefinitions
                    .slice(0, expecting - got)
                    .map(function (definition) { return ("`" + definition.name + "`"); });
                throw new UsageError("Expecting parameter(s) " + missingArgNames.join(', '), this.helpProvider);
            }
        }
        {
            var missingOptionNames = requiredOptionMap && Object.keys(requiredOptionMap);
            if (missingOptionNames && missingOptionNames.length) {
                throw new UsageError("Missing required option(s) `" + missingOptionNames.join('`, `') + "`", this.helpProvider);
            }
        }
        for (var _a = 0, pendingParamDefinitions_1 = pendingParamDefinitions; _a < pendingParamDefinitions_1.length; _a++) {
            var definition = pendingParamDefinitions_1[_a];
            var defaultValue = definition.default;
            var value = typeof defaultValue === 'string' ?
                castArgument(defaultValue, definition.name, definition.type, definition.validators) :
                defaultValue;
            commandArgs.push(value);
        }
        if (paramsDefinition &&
            paramsDefinition.required &&
            !commandExtraArgs.length) {
            throw new UsageError("Expecting at least one element for variadic parameters `" + paramsDefinition.name + "`", this.helpProvider);
        }
        return {
            args: commandArgs,
            extraArgs: paramsDefinition && commandExtraArgs,
            options: commandOptions,
            context: this.contextConstructor ? context : undefined
        };
        function consumeFlags(flags) {
            for (var i = 0; i < flags.length; i++) {
                var flag = flags[i];
                if (!hasOwnProperty.call(optionFlagMapping, flag)) {
                    throw new UsageError("Unknown option flag \"" + flag + "\"", that.helpProvider);
                }
                var name_3 = optionFlagMapping[flag];
                var definition = optionDefinitionMap[name_3];
                if (definition.required) {
                    delete requiredOptionMap[name_3];
                }
                if (definition.toggle) {
                    commandOptions[definition.key] = true;
                }
                else {
                    if (i !== flags.length - 1) {
                        throw new UsageError('Only the last flag in a sequence can refer to an option instead of a toggle', that.helpProvider);
                    }
                    consumeOption(definition);
                }
            }
        }
        function consumeToggleOrOption(name) {
            if (!hasOwnProperty.call(optionDefinitionMap, name)) {
                throw new UsageError("Unknown option `" + name + "`", that.helpProvider);
            }
            var definition = optionDefinitionMap[name];
            if (definition.required) {
                delete requiredOptionMap[name];
            }
            if (definition.toggle) {
                commandOptions[definition.key] = true;
            }
            else {
                consumeOption(definition);
            }
        }
        function consumeOption(definition) {
            var name = definition.name, key = definition.key, type = definition.type, validators = definition.validators;
            var arg = args.shift();
            if (arg === undefined) {
                throw new UsageError("Expecting value for option `" + name + "`", that.helpProvider);
            }
            if (arg[0] === '-') {
                throw new UsageError("Expecting a value instead of an option or toggle \"" + arg + "\" for option `" + name + "`", that.helpProvider);
            }
            commandOptions[key] = castArgument(arg, name, type, validators);
        }
        // TODO: support casting provider object.
        function castArgument(arg, name, type, validators) {
            var value;
            switch (type) {
                case String:
                    value = arg;
                    break;
                case Number:
                    value = Number(arg);
                    if (isNaN(value)) {
                        throw new error_1.ExpectedError("Value \"" + arg + "\" cannot be casted to number");
                    }
                    break;
                case Boolean:
                    if (/^(?:f|false)$/i.test(arg)) {
                        value = false;
                    }
                    else {
                        var n = Number(arg);
                        value = isNaN(n) ? true : Boolean(n);
                    }
                    break;
                default:
                    if (object_1.isStringCastable(type)) {
                        value = type.cast(arg, context);
                    }
                    else {
                        throw new Error("Type `" + (type.name || type) + "` cannot be casted from a string, see `StringCastable` interface for more information");
                    }
                    break;
            }
            for (var _i = 0, validators_1 = validators; _i < validators_1.length; _i++) {
                var validator = validators_1[_i];
                if (validator instanceof RegExp) {
                    if (!validator.test(value)) {
                        throw new error_1.ExpectedError("Invalid value for \"" + name + "\"");
                    }
                }
                else {
                    validator.validate(arg, name);
                }
            }
            return value;
        }
    };
    return ArgsParser;
}());
var UsageError = (function (_super) {
    __extends(UsageError, _super);
    function UsageError(message, helpProvider) {
        _super.call(this, message);
        this.helpProvider = helpProvider;
    }
    UsageError.prototype.print = function (stdout, stderr) {
        _super.prototype.print.call(this, stdout, stderr);
        this
            .helpProvider
            .getHelp()
            .print(stdout, stderr);
    };
    return UsageError;
}(error_1.ExpectedError));
exports.UsageError = UsageError;
//# sourceMappingURL=cli.js.map