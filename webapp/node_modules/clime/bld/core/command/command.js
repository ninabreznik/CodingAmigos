"use strict";
var _1 = require('./');
/**
 * Command context.
 */
var Context = (function () {
    function Context(_a) {
        var cwd = _a.cwd, commands = _a.commands;
        this.cwd = cwd;
        this.commands = commands;
    }
    return Context;
}());
exports.Context = Context;
/**
 * The abstract `Command` class to be extended.
 */
var Command = (function () {
    function Command() {
    }
    /**
     * Get the help object of current command.
     */
    // Note: we are using method instead of getter here to avoid issue with
    // `__extends` helper emitted by TypeScript.
    Command.getHelp = function () {
        return _1.HelpInfo.build(this);
    };
    /** @internal */
    Command.decorated = false;
    /** @internal */
    Command.requiredParamsNumber = 0;
    return Command;
}());
exports.Command = Command;
/**
 * The `command()` decorator that decorates concrete class of `Command`.
 */
function command(options) {
    if (options === void 0) { options = {}; }
    return function (target) {
        target.brief = options.brief;
        target.description = options.description;
        // Validate param definitions.
        var paramDefinitions = target.paramDefinitions || [];
        var paramsDefinition = target.paramsDefinition;
        var variadicParamsRequired = paramsDefinition && paramsDefinition.required;
        if (paramDefinitions.length) {
            var hasOptional = false;
            for (var i = 0; i < paramDefinitions.length; i++) {
                var definition = paramDefinitions[i];
                if (!definition) {
                    throw new Error("Expecting parameter definition at position " + i);
                }
                if (hasOptional) {
                    if (definition.required) {
                        throw new Error('Required parameter cannot follow optional ones');
                    }
                }
                else {
                    if (definition.required) {
                        target.requiredParamsNumber++;
                    }
                    else {
                        if (variadicParamsRequired) {
                            throw new Error('Parameter cannot be optional if variadic parameters are required');
                        }
                        hasOptional = true;
                    }
                }
            }
        }
        if (paramsDefinition && paramsDefinition.index !== paramDefinitions.length) {
            throw new Error('Expecting variadic parameters to be adjacent to other parameters');
        }
        // Prepare option defintions.
        var types = Reflect.getMetadata('design:paramtypes', target.prototype, 'execute');
        if (!types) {
            throw new Error("No parameter type information found, please add `@metadata` decorator to method `execute` if no other decorator applied");
        }
        var optionsConstructorCandidateIndex = paramDefinitions.length + (target.paramsDefinition ? 1 : 0);
        var optionsConstructorCandidate = types[optionsConstructorCandidateIndex];
        var contextConstructorCandidateIndex;
        if (optionsConstructorCandidate && optionsConstructorCandidate.prototype instanceof _1.Options) {
            target.optionsConstructor = optionsConstructorCandidate;
            target.optionDefinitions = optionsConstructorCandidate.definitions;
            contextConstructorCandidateIndex = optionsConstructorCandidateIndex + 1;
        }
        else {
            contextConstructorCandidateIndex = optionsConstructorCandidateIndex;
        }
        var contextConstructorCandidate = types[contextConstructorCandidateIndex];
        if (contextConstructorCandidate && (contextConstructorCandidate === Context ||
            contextConstructorCandidate.prototype instanceof Context)) {
            target.contextConstructor = contextConstructorCandidate;
        }
        target.decorated = true;
    };
}
exports.command = command;
/**
 * The `metadata` decorator does nothing at runtime. It is only used to have
 * TypeScript emits type metadata for `execute` method that has no other
 * decorators.
 */
exports.metadata = function () { };
//# sourceMappingURL=command.js.map