"use strict";
var Path = require('path');
var Tmp = require('tmp');
var clime_1 = require('clime');
var thenfail_1 = require('thenfail');
var FS = require('fs-extra');
var extract = require('extract-zip');
var fetch = require('node-fetch');
var semver_match_1 = require('semver-match');
var config = require('../config');
var hasOwnProperty = Object.prototype.hasOwnProperty;
function getPackageMetadata(range) {
    if (range === void 0) { range = '*'; }
    var versionsUrl = config.registry + "/sdks.json";
    return thenfail_1.default
        .resolve(fetch(versionsUrl))
        .then(function (res) { return res.json(); })
        .then(function (data) {
        var tags = data.tags, packages = data.packages;
        var versions = Object.keys(packages);
        var version = semver_match_1.default(range, versions, tags);
        if (!version) {
            throw new clime_1.ExpectedError("No matching version found for \"" + range + "\"");
        }
        var dists = packages[version].dists;
        var priorPlatformName = process.platform + "-" + process.arch;
        var possiblePlatformNames = [
            priorPlatformName,
            process.platform
        ];
        var dist;
        var platformName;
        for (var _i = 0, possiblePlatformNames_1 = possiblePlatformNames; _i < possiblePlatformNames_1.length; _i++) {
            var platformName_1 = possiblePlatformNames_1[_i];
            if (hasOwnProperty.call(dists, platformName_1)) {
                var rawDist = dists[platformName_1];
                dist = {
                    platform: platformName_1,
                    format: rawDist.format,
                    url: rawDist.url,
                    strip: rawDist.strip
                };
                break;
            }
        }
        if (!dist) {
            throw new clime_1.ExpectedError("No matching distribution package found for platform \"" + priorPlatformName + "\"");
        }
        return {
            version: version,
            dist: dist
        };
    });
}
exports.getPackageMetadata = getPackageMetadata;
function downloadPackage(type, metadata) {
    var version = metadata.version, _a = metadata.dist, platform = _a.platform, format = _a.format, url = _a.url;
    var packageBaseName = type + "-" + version + "-" + platform;
    var packageName = packageBaseName + "." + format;
    var metadataFileName = packageBaseName + ".json";
    var packagePath = Path.join(config.downloadsPath, packageName);
    var metadataFilePath = Path.join(config.downloadsPath, metadataFileName);
    if (FS.existsSync(packagePath) && FS.existsSync(metadataFilePath)) {
        return thenfail_1.default.resolve(packagePath);
    }
    var tmpPackagePath = Tmp.tmpNameSync();
    return thenfail_1.default
        .resolve(fetch(url))
        .then(function (res) {
        var resStream = res.body;
        var writeStream = FS.createWriteStream(tmpPackagePath);
        resStream.pipe(writeStream);
        return thenfail_1.default.for(writeStream, 'close', [resStream]);
    })
        .then(function () {
        FS.copySync(tmpPackagePath, packagePath);
        var metadataJSON = JSON.stringify(metadata, undefined, 4);
        FS.writeFileSync(metadataFilePath, metadataJSON);
        return packagePath;
    });
}
exports.downloadPackage = downloadPackage;
function extractPackage(type, packagePath, targetPath) {
    if (targetPath === void 0) { targetPath = config.targetPathMap[type]; }
    FS.removeSync(targetPath);
    var metadataFilePath = packagePath.replace(/\.\w+$/, '') + ".json";
    var metadata = require(metadataFilePath);
    return thenfail_1.default.invoke(extract, packagePath, {
        dir: targetPath,
        strip: metadata.dist.strip
    });
}
exports.extractPackage = extractPackage;
//# sourceMappingURL=index.js.map