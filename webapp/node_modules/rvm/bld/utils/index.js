"use strict";
var Path = require('path');
var Chalk = require('chalk');
var FS = require('fs-extra');
var thenfail_1 = require('thenfail');
var which = require('which');
var config = require('../config');
function log(verb) {
    var objects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
    }
    if (/^[A-Z]+$/.test(verb)) {
        verb = Chalk.green(verb);
    }
    console.log.apply(console, [verb].concat(objects));
}
exports.log = log;
function warn() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i - 0] = arguments[_i];
    }
    console.log.apply(console, [Chalk.yellow('WARN')].concat(objects));
}
exports.warn = warn;
function checkPath(type) {
    if (type !== 'sdk') {
        throw new TypeError("Project type \"" + type + "\" is not supported");
    }
    return thenfail_1.default
        .invoke(which, config.rapExecName)
        .then(function (path) { return Path.relative(path, config.rapExecPath) === ''; }, function () { return false; });
}
exports.checkPath = checkPath;
function createNpmBinScript(execName) {
    var fileName;
    var script;
    if (process.platform === 'win32') {
        fileName = execName + ".cmd";
        script = ".\\.ruff\\bin\\" + execName + ".exe %*";
    }
    else {
        fileName = execName;
        script = "#!/bin/sh\n./.ruff/bin/" + execName + " \"$@\"";
    }
    var filePath = Path.resolve('node_modules/.bin', fileName);
    FS.outputFileSync(filePath, script);
    if (process.platform !== 'win32') {
        FS.chmodSync(filePath, 484);
    }
}
exports.createNpmBinScript = createNpmBinScript;
//# sourceMappingURL=index.js.map