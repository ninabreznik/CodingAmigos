/**
 * ThenFail v0.4
 * Just another Promises/A+ Library
 *
 * https://github.com/vilic/thenfail
 *
 * MIT License
 */
import { EventEmitter } from 'events';
import { ChildProcess } from 'child_process';
import { Context } from './context';
export interface PromiseLike<T> {
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @return A Promise for the completion of which ever callback is executed.
     */
    then<TResult>(onfulfilled?: (value: T) => TResult | PromiseLike<TResult>, onrejected?: (reason: any) => TResult | PromiseLike<TResult>): PromiseLike<TResult>;
    then<TResult>(onfulfilled?: (value: T) => TResult | PromiseLike<TResult>, onrejected?: (reason: any) => void): PromiseLike<TResult>;
}
export declare type Resolvable<T> = PromiseLike<T> | T;
export declare type Resolver<T> = (resolve: (value?: Resolvable<T>) => void, reject: (reason: any) => void) => void;
export declare type OnFulfilledHandler<T, TResult> = (value: T) => Resolvable<TResult>;
export declare type OnFulfilledSpreadHandler<TResult> = (...values: any[]) => Resolvable<TResult>;
export declare type OnRejectedHandler<TResult> = (reason: any) => Resolvable<TResult>;
export declare type OnAnyHandler<TResult> = (valueOrReason: any) => Resolvable<TResult>;
export declare type OnContextDisposedHandler = () => void;
export declare type NodeStyleCallback<T> = (error?: any, value?: T) => void;
export declare type MapCallback<T, TResult> = (value: T, index: number, array: T[]) => Resolvable<TResult>;
export declare type ReduceCallback<T, TResult> = (previousValue: TResult, currentValue: T, index: number, array: T[]) => Resolvable<TResult>;
export declare type EachCallback<T> = (value: T, index: number, array: T[]) => Resolvable<boolean | void>;
export declare type WaterfallCallback<T, TResult> = (value: T, result: TResult, index: number, array: T[]) => Resolvable<TResult>;
/**
 * ThenFail promise options.
 */
export declare let options: {
    disableUnrelayedRejectionWarning: boolean;
    logger: {
        log: (message?: any, ...optionalParams: any[]) => void;
        warn: (message?: any, ...optionalParams: any[]) => void;
        error: (message?: any, ...optionalParams: any[]) => void;
    };
};
export declare class Promise<T> implements PromiseLike<T> {
    /** To make sure type checking work with value. */
    private __generic;
    /** Current state of this promise. */
    private _state;
    /**
     * Indicates whether `onfulfilled` or `onrejected` handler has been called
     * but the resolved value has not become fulfilled yet.
     */
    private _running;
    /** Indicates whether this promise has been relayed or notified as unrelayed. */
    private _handled;
    /** The fulfilled value or rejected reason associated with this promise. */
    private _valueOrReason;
    /** Context of this promise. */
    private _context;
    /** Label of this promise. */
    private _label;
    /**
     * Next promise in the chain.
     * Avoid using an array if not necessary due to performance issue,
     * the same way applies to `_handledPromise(s)`.
     * If `_chainedPromise` is not undefined, `_chainedPromises` must be undefined.
     * Vice versa.
     */
    private _chainedPromise;
    /** Next promises in the chain. */
    private _chainedPromises;
    /**
     * Promise that will share the same state (and value/reason).
     *
     * Example:
     *
     * ```ts
     * let promiseA = Promise.then(() => {
     *     let promiseB = Promise.then(() => ...);
     *     return promiseB;
     * });
     * ```
     *
     * The state of `promiseB` will determine the state of `promiseA`.
     * And `promiseA` will then be in here.
     */
    private _handledPromise;
    /** Promises that will share the same state (and value/reason). */
    private _handledPromises;
    private _onPreviousFulfilled;
    private _onPreviousRejected;
    private _onContextDisposed;
    /**
     * Promise constructor.
     */
    constructor();
    constructor(resolver: Resolver<T>);
    constructor(context: Context);
    /**
     * Get the state from previous promise in chain.
     */
    private _grab(previousState, previousValueOrReason?);
    /**
     * Invoke `onfulfilled` or `onrejected` handlers.
     */
    private _run(handler, previousValueOrReason);
    /**
     * The resolve process defined in Promises/A+ specifications.
     */
    private _unpack(value, callback);
    /**
     * Decide whether to call `_relay`, `_skip` or `_goto`.
     */
    private _decide(state, valueOrReason?);
    /**
     * Set the state of current promise and relay it to next promises.
     */
    private _relay(state, valueOrReason?);
    /**
     * Skip some promises.
     */
    private _skip(signal?);
    /**
     * Go to a specific promise that matches given label.
     */
    private _goto(signal);
    /**
     * Set handlers to undefined.
     */
    private _relax();
    /**
     * The `then` method that follows
     * [Promises/A+ specifications](https://promisesaplus.com).
     * @param onfulfilled Fulfillment handler.
     * @param onrejected Rejection handler.
     * @return Created promise.
     */
    then<TResult>(onfulfilled: OnFulfilledHandler<T, TResult>, onrejected?: OnRejectedHandler<TResult>): Promise<TResult>;
    /**
     * Resolve the promise with a value or thenable.
     * @param resolvable The value to fulfill or thenable to resolve.
     */
    resolve(resolvable?: Resolvable<T>): void;
    /**
     * Reject this promise with a reason.
     * @param reason Rejection reason.
     */
    reject(reason: any): void;
    /**
     * Like `then` but accepts the first extra parameter as the label of
     * current part.
     * @param label Part label.
     * @param onfulfilled Fulfillment handler.
     * @param onrejected Rejection handler.
     * @return Created promise.
     */
    label<TResult>(label: string, onfulfilled: OnFulfilledHandler<T, TResult>, onrejected?: OnRejectedHandler<TResult>): Promise<TResult>;
    /**
     * Set up the interruption handler of the promise.
     * An interruption handler will be called if either the `onfulfilled`
     * or `onrejected` handler of the promise has been called but
     * interrupted due to context disposal.
     * (by break signal or the canceling of the context).
     * @param oninerrupted Interruption handler.
     * @return Current promise.
     */
    interruption(oncontextdisposed: OnContextDisposedHandler): Promise<T>;
    /**
     * Enclose current promise context.
     * @return Current promise.
     */
    enclose(): Promise<T>;
    /**
     * Create a promise that will be fulfilled in given time after
     * its previous promise becomes fulfilled.
     * The fulfilled value will be relayed.
     * @param timeout Timeout in milliseconds.
     * @return Current promise.
     */
    delay(timeout: number): Promise<T>;
    /**
     * Reject the promise with `TimeoutError` if it's still pending after
     * timeout. The timer starts once this method is called
     * (usually before the fulfillment of previous promise).
     * @param timeout Timeout in milliseconds.
     * @return Current promise.
     */
    timeout(timeout: number, message?: string): Promise<T>;
    /**
     * Handle another promise or node style callback with the value or
     * reason of current promise.
     * @param promise A promise with the same type as current promise.
     * @return Current promise.
     */
    handle(promise: Promise<T>): Promise<T>;
    /**
     * @param callback Node style callback.
     * @return Current promise.
     */
    handle(callback: NodeStyleCallback<T>): Promise<T>;
    /**
     * Create a disposable resource promise.
     * @param disposor A synchronous function to handle resource disposing.
     * @return Created disposable resource promise.
     */
    disposable(disposer: Disposer<T>): Promise<Disposable<T>>;
    /**
     * Like `then` with only an `onfulfilled` handler, but will relay the
     * previous fulfilled value instead of value returned by its own
     * `onfulfilled` handler.
     * @param onfulfilled Fulfillment handler.
     * @return Created promise.
     */
    tap(onfulfilled: OnFulfilledHandler<T, void>): Promise<T>;
    /**
     * Spread a fulfilled array-like value as arguments of the given handler.
     * @param onfulfilled Handler that takes the spread arguments.
     * @return Created promise.
     */
    spread<TResult>(onfulfilled: OnFulfilledSpreadHandler<TResult>): Promise<TResult>;
    /**
     * A shortcut of `promise.then(undefined, onrejected)`.
     */
    fail(onrejected: OnRejectedHandler<T>): Promise<T>;
    /**
     * Like `fail` but can specify type of reason to catch.
     * @param onrejected Rejection handler.
     * @return Created promise.
     */
    catch(onrejected: OnRejectedHandler<T>): Promise<T>;
    /**
     * @param ReasonType Type of reasons to catch.
     * @param onrejected Rejection handler.
     * @return Created promise.
     */
    catch(ReasonType: Function, onrejected: OnRejectedHandler<T>): Promise<T>;
    /**
     * A shortcut of `Promise.map`, assuming the fulfilled value of
     * previous promise is a array.
     * @param callback Map callback.
     * @return Created promise.
     */
    map<T>(callback: MapCallback<any, T>): Promise<T[]>;
    /**
     * A shortcut of `Promise.map`, assuming the fulfilled value of
     * previous promise is a array.
     * @param callback Map callback.
     * @return Created promise.
     */
    reduce<TResult>(callback: ReduceCallback<any, TResult>, initialValue?: TResult): Promise<TResult>;
    /**
     * A shortcut of `Promise.each`, assuming the fulfilled value of
     * previous promise is a array.
     * @param callback Each callback.
     * @return Created promise.
     */
    each<T>(callback: EachCallback<T>): Promise<boolean>;
    /**
     * A shortcut of `Promise.waterfall`, take the fulfilled value of
     * previous promise as initial result.
     */
    waterfall<TValue>(values: TValue[], callback: WaterfallCallback<TValue, T>): Promise<T>;
    /**
     * A shortcut of `Promise.retry`.
     */
    retry<TResult>(callback: RetryCallback<TResult>): Promise<TResult>;
    retry<TResult>(options: RetryOptions, callback: RetryCallback<TResult>): Promise<TResult>;
    /**
     * Log the value specified on fulfillment, or if not, the fulfilled value or
     * rejection reason of current promise after the previous promise becomes settled.
     * @param object Specified value to log.
     * @return Created promise.
     */
    log(object?: any): Promise<T>;
    /**
     * Call `this.then` with `onrejected` handler only, and throw the
     * rejection reason if any.
     */
    done(): void;
    /**
     * (get) A promise that will be rejected with a pre-break signal if previous
     * promise is fulfilled with a non-`false` value.
     */
    break: Promise<any>;
    /**
     * Create a promise that will be rejected with a goto signal if previous
     * promise is fulfilled with a non-`false` value.
     */
    goto(label: string, value?: any): Promise<any>;
    /**
     * (get) A promise that will eventually be fulfilled with `undefined`.
     */
    void: Promise<void>;
    /**
     * (get) A promise that will eventually been fulfilled with `true`.
     */
    true: Promise<boolean>;
    /**
     * (get) A promise that will eventually been fulfilled with `false`.
     */
    false: Promise<boolean>;
    /**
     * (get) Get the context of current promise.
     */
    context: Context;
    /**
     * (get) A boolean that indicates whether the promise is pending.
     */
    pending: boolean;
    /**
     * (get) A boolean that indicates whether the promise is fulfilled.
     */
    fulfilled: boolean;
    /**
     * (get) A boolean that indicates whether the promise is rejected.
     */
    rejected: boolean;
    /**
     * (get) A boolean that indicates whether the promise is interrupted.
     */
    skipped: boolean;
    /**
     * @deperacated
     * (get) A boolean that indicates whether the promise is interrupted.
     */
    interrupted: boolean;
    /**
     * A shortcut of `Promise.void.then(onfulfilled)`.
     * @param onfulfilled Fulfillment handler.
     * @return Created promise.
     */
    static then<TResult>(onfulfilled: OnFulfilledHandler<void, TResult>): Promise<TResult>;
    /**
     * Resolve a value or thenable as a promise.
     * @return The value itself if it's a ThenFail Promise,
     *     otherwise the created promise.
     */
    static resolve(): Promise<void>;
    /**
     * @return The value itself if it's a ThenFail Promise,
     *     otherwise the created promise.
     */
    static resolve<T>(resolvable: Resolvable<T>): Promise<T>;
    /**
     * Create a promise rejected by specified reason.
     * @param reason Rejection reason.
     * @return Created promise.
     */
    static reject(reason: any): Promise<void>;
    /**
     * @param reason Rejection reason.
     * @return Created promise.
     */
    static reject<T>(reason: any): Promise<T>;
    /**
     * Alias of `Promise.resolve`.
     */
    static when<T>(value: Resolvable<T>): Promise<T>;
    /**
     * Create a promise with given context.
     * @param context Promise context.
     * @return Created promise.
     */
    static context(context: Context): Promise<void>;
    /**
     * Create a promise that will be fulfilled with `undefined` in given
     * time.
     * @param timeout Timeout in milliseconds.
     * @return Created promise.
     */
    static delay(timeout: number): Promise<void>;
    /**
     * Create a promise that will be fulfilled:
     *
     *   1. when all values are fulfilled.
     *   2. with the value of an array of fulfilled values.
     *
     * And will be rejected:
     *
     *   1. if any of the values is rejected.
     *   2. with the reason of the first rejection as its reason.
     *   3. once the first rejection happens.
     *
     * @return Created promise.
     */
    static all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(values: [Resolvable<T1>, Resolvable<T2>, Resolvable<T3>, Resolvable<T4>, Resolvable<T5>, Resolvable<T6>, Resolvable<T7>, Resolvable<T8>, Resolvable<T9>, Resolvable<T10>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;
    static all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(values: [Resolvable<T1>, Resolvable<T2>, Resolvable<T3>, Resolvable<T4>, Resolvable<T5>, Resolvable<T6>, Resolvable<T7>, Resolvable<T8>, Resolvable<T9>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;
    static all<T1, T2, T3, T4, T5, T6, T7, T8>(values: [Resolvable<T1>, Resolvable<T2>, Resolvable<T3>, Resolvable<T4>, Resolvable<T5>, Resolvable<T6>, Resolvable<T7>, Resolvable<T8>]): Promise<[T1, T2, T3, T4, T5, T6, T7, T8]>;
    static all<T1, T2, T3, T4, T5, T6, T7>(values: [Resolvable<T1>, Resolvable<T2>, Resolvable<T3>, Resolvable<T4>, Resolvable<T5>, Resolvable<T6>, Resolvable<T7>]): Promise<[T1, T2, T3, T4, T5, T6, T7]>;
    static all<T1, T2, T3, T4, T5, T6>(values: [Resolvable<T1>, Resolvable<T2>, Resolvable<T3>, Resolvable<T4>, Resolvable<T5>, Resolvable<T6>]): Promise<[T1, T2, T3, T4, T5, T6]>;
    static all<T1, T2, T3, T4, T5>(values: [Resolvable<T1>, Resolvable<T2>, Resolvable<T3>, Resolvable<T4>, Resolvable<T5>]): Promise<[T1, T2, T3, T4, T5]>;
    static all<T1, T2, T3, T4>(values: [Resolvable<T1>, Resolvable<T2>, Resolvable<T3>, Resolvable<T4>]): Promise<[T1, T2, T3, T4]>;
    static all<T1, T2, T3>(values: [Resolvable<T1>, Resolvable<T2>, Resolvable<T3>]): Promise<[T1, T2, T3]>;
    static all<T1, T2>(values: [Resolvable<T1>, Resolvable<T2>]): Promise<[T1, T2]>;
    static all<T1>(values: [Resolvable<T1>]): Promise<[T1]>;
    /**
     * @param resolvables Resolvables involved.
     * @return Created promise.
     */
    static all<T>(resolvables: Resolvable<T>[]): Promise<T[]>;
    /**
     * Create a promise that is settled the same way as the first passed promise to settle.
     * It resolves or rejects, whichever happens first.
     * @param resolvables Promises or values to race.
     * @return Created promise.
     */
    static race<TResult>(resolvables: Resolvable<TResult>[]): Promise<TResult>;
    /**
     * A promise version of `Array.prototype.map`.
     * @param values Values to map.
     * @param callback Map callback.
     * @return Created promise.
     */
    static map<T, TResult>(values: T[], callback: MapCallback<T, TResult>): Promise<TResult[]>;
    /**
     * A promise version of `Array.prototype.reduce`.
     * @param values Values to reduce.
     * @param callback Reduce callback.
     * @return Created promise.
     */
    static reduce<T, TResult>(values: T[], callback: ReduceCallback<T, TResult>, initialValue?: TResult): Promise<TResult>;
    /**
     * (breakable) Iterate elements in an array one by one.
     * TResult `false` or a promise that will eventually be fulfilled with
     * `false` to interrupt iteration.
     * @param values Values to iterate.
     * @param callback Each callback.
     * @return A promise that will be fulfiled with a boolean which
     *     indicates whether the iteration completed without interruption.
     */
    static each<T>(values: T[], callback: EachCallback<T>): Promise<boolean>;
    /**
     * (breakable) Pass the last result to the same callback with pre-set values.
     * @param values Pre-set values that will be passed to the callback one
     *     by one.
     * @param initialResult The initial result for the very first call.
     * @param callback Waterfall callback.
     */
    static waterfall<T, TResult>(values: T[], initialResult: TResult, callback: WaterfallCallback<T, TResult>): Promise<TResult>;
    /**
     * Retry the process in the callback for several times.
     * @param callback Retry callback.
     * @return Created promise.
     */
    static retry<TResult>(callback: RetryCallback<TResult>): Promise<TResult>;
    /**
     * @param options Retry options.
     * @param callback Retry callback.
     * @return Created promise.
     */
    static retry<TResult>(options: RetryOptions, callback: RetryCallback<TResult>): Promise<TResult>;
    /**
     * Use a disposable resource and dispose it after been used.
     * @param disposable The disposable resource or a thenable of
     *     disposable resource.
     * @param handler Using handler.
     * @return Created promise.
     */
    static using<T, TResult>(disposable: Resolvable<Disposable<T>>, handler: OnFulfilledHandler<T, TResult>): Promise<TResult>;
    /**
     * Invoke a Node style asynchronous function that accepts the last
     * argument as callback.
     * @param fn Node style asynchronous function.
     * @param args Arguments.
     * @return Created promise.
     */
    static invoke(fn: Function, ...args: any[]): Promise<void>;
    static invoke<TResult>(fn: Function, ...args: any[]): Promise<TResult>;
    private static _forChildProcess(process);
    private static _forEventEmitter<T>(emitter, types, errorEmitters?);
    /**
     * Create a promise for a `ChildProcess` object.
     * @param process - The process to listen on 'exit' and 'error' events for fulfillment
     *     or rejection.
     */
    static for(process: ChildProcess): Promise<void>;
    /**
     * Create a promise for an event emitter.
     * @param emitter - The emitter to listen on 'error' event for rejection,
     *     and given event types for fulfillment.
     * @param type - A string or an array of string of event types for
     *     fulfillment.
     * @param errorEmitters - Other emitters to listen on 'error' event for rejection.
     */
    static for(emitter: EventEmitter, types: string | string[], errorEmitters?: EventEmitter[]): Promise<void>;
    static for<T>(emitter: EventEmitter, types: string | string[], errorEmitters?: EventEmitter[]): Promise<T>;
    /**
     * (fake statement) This getter will always throw a break signal that interrupts the promises chain.
     *
     * Example:
     *
     * ```ts
     * promise
     *     .then(() => {
     *         if (toBreak) {
     *             Promise.break;
     *         }
     *
     *         // Or not to break.
     *     })
     *     .then(() => {
     *         // If `toBreak` is true, it will never enter this handler.
     *     }, () => {
     *         // Nor this handler.
     *     });
     * ```
     */
    static break: void;
    /** (get) The break signal. */
    static breakSignal: any;
    /** (get) The pre-break signal. */
    static preBreakSignal: any;
    /** (fake statement) This method will throw an `GoToSignal` with specified `label`. */
    static goto(label: string, value?: any): void;
    /**
     * (get) A promise that has already been fulfilled with `undefined`.
     */
    static void: Promise<void>;
    /**
     * (get) A promise that has already been fulfilled with `true`.
     */
    static true: Promise<boolean>;
    /**
     * (get) A promise that has already been fulfilled with `false`.
     */
    static false: Promise<boolean>;
}
export declare type RetryCallback<TResult> = (lastReason: any, attemptIndex: number) => Resolvable<TResult>;
export interface RetryOptions {
    /** Try limit times (defaults to 3). */
    limit?: number;
    /** Interval between two tries (defaults to 0). */
    interval?: number;
}
export declare type Disposer<TResource> = (resource: TResource) => void;
export interface Disposable<TResource> {
    resource: TResource;
    dispose: Disposer<TResource>;
}
export declare const using: typeof Promise.using;
export declare const invoke: typeof Promise.invoke;
